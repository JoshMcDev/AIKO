import AppCore
import Foundation
import SwiftUI
#if os(iOS)
    import UIKit
#else
    import AppKit
#endif

@MainActor
@Observable
public final class AppViewModel {
    // MARK: - Child ViewModels
    public var documentGenerationViewModel = DocumentGenerationViewModel()
    public var profileViewModel = ProfileViewModel()
    public var onboardingViewModel = OnboardingViewModel()
    public var acquisitionsListViewModel = AcquisitionsListViewModel()
    public var acquisitionChatViewModel = AcquisitionChatViewModel()
    public var settingsViewModel = SettingsViewModel()
    public var documentScannerViewModel = DocumentScannerViewModel()
    public var globalScanViewModel = GlobalScanViewModel()

    // MARK: - Navigation State
    public var isOnboardingCompleted: Bool = false
    public var hasProfile: Bool = false
    public var showingMenu: Bool = false
    public var selectedMenuItem: MenuItem?
    public var showingQuickReferences: Bool = false
    public var selectedQuickReference: QuickReference?
    public var showingProfile: Bool = false
    public var showingAcquisitions: Bool = false
    public var showingUserGuide: Bool = false
    public var showingSearchTemplates: Bool = false
    public var showingSettings: Bool = false
    public var showingAcquisitionChat: Bool = false
    public var showingDocumentScanner: Bool = false
    public var showingQuickDocumentScanner: Bool = false
    public var loadedAcquisition: AppCore.Acquisition?
    public var loadedAcquisitionDisplayName: String?
    public var isChatMode: Bool = false
    public var showingDownloadOptions: Bool = false
    public var downloadTargetAcquisitionId: UUID?
    public var downloadTargetAcquisition: AppCore.Acquisition?
    public var showingSAMGovLookup: Bool = false

    // MARK: - Document Sharing State
    public var showingDocumentSelection: Bool = false
    public var shareTargetAcquisitionId: UUID?
    public var shareMode: ShareMode = .singleDocument
    public var selectedDocumentsForShare: Set<UUID> = []
    public var shareItems: [Any] = []

    // MARK: - Error Handling
    public var error: Error?
    public var showingError: Bool = false

    public init() {}

    // MARK: - Navigation Actions
    public func toggleMenu() {
        showingMenu.toggle()
    }

    public func selectMenuItem(_ item: MenuItem) {
        selectedMenuItem = item
        showingMenu = false

        switch item {
        case .profile:
            showingProfile = true
        case .acquisitions:
            showingAcquisitions = true
        case .userGuide:
            showingUserGuide = true
        case .searchTemplates:
            showingSearchTemplates = true
        case .settings:
            showingSettings = true
        }
    }

    public func startAcquisitionChat(for acquisition: AppCore.Acquisition) {
        loadedAcquisition = acquisition
        loadedAcquisitionDisplayName = acquisition.title
        showingAcquisitionChat = true
        isChatMode = true
    }

    public func closeAcquisitionChat() {
        showingAcquisitionChat = false
        loadedAcquisition = nil
        loadedAcquisitionDisplayName = nil
        isChatMode = false
    }

    public func startDocumentScanner() {
        showingDocumentScanner = true
    }

    public func startQuickDocumentScanner() {
        showingQuickDocumentScanner = true
    }

    public func closeDocumentScanner() {
        showingDocumentScanner = false
        showingQuickDocumentScanner = false
    }

    // MARK: - Download Actions
    public func showDownloadOptions(for acquisition: AppCore.Acquisition) {
        downloadTargetAcquisition = acquisition
        downloadTargetAcquisitionId = acquisition.id
        showingDownloadOptions = true
    }

    public func hideDownloadOptions() {
        showingDownloadOptions = false
        downloadTargetAcquisition = nil
        downloadTargetAcquisitionId = nil
    }

    // MARK: - Share Actions
    public func showDocumentSelection(for acquisitionId: UUID, mode: ShareMode = .singleDocument) {
        shareTargetAcquisitionId = acquisitionId
        shareMode = mode
        showingDocumentSelection = true
    }

    public func hideDocumentSelection() {
        showingDocumentSelection = false
        shareTargetAcquisitionId = nil
        selectedDocumentsForShare.removeAll()
        shareItems.removeAll()
    }

    public func toggleDocumentSelection(_ documentId: UUID) {
        if selectedDocumentsForShare.contains(documentId) {
            selectedDocumentsForShare.remove(documentId)
        } else {
            selectedDocumentsForShare.insert(documentId)
        }
    }

    // MARK: - Error Handling
    public func setError(_ error: AppError) {
        self.error = error
        self.showingError = true
    }

    public func clearError() {
        self.error = nil
        self.showingError = false
    }
}

// MARK: - Supporting Types
public enum MenuItem: String, CaseIterable, Identifiable {
    case profile = "Profile"
    case acquisitions = "Acquisitions"
    case userGuide = "User Guide"
    case searchTemplates = "Search Templates"
    case settings = "Settings"

    public var id: String { rawValue }

    public var systemImage: String {
        switch self {
        case .profile:
            return "person.circle"
        case .acquisitions:
            return "doc.text"
        case .userGuide:
            return "book"
        case .searchTemplates:
            return "magnifyingglass"
        case .settings:
            return "gear"
        }
    }
}

public enum ShareMode: String, CaseIterable {
    case singleDocument = "Single Document"
    case multipleDocuments = "Multiple Documents"
    case fullAcquisition = "Full Acquisition"
}

public enum QuickReference: String, CaseIterable, Identifiable {
    case farBasics = "FAR Basics"
    case dfars = "DFARS"
    case contractTypes = "Contract Types"
    case socioeconomic = "Socioeconomic Programs"

    public var id: String { rawValue }
}

// MARK: - Feature ViewModels

@MainActor
@Observable
public final class DocumentGenerationViewModel {
    public var documentType: DocumentType = .sow
    public var title: String = ""
    public var requirements: String = ""
    public var isGenerating: Bool = false
    public var generationProgress: Double = 0.0
    public var generatedContent: String = ""
    public var error: Error?

    public init() {}

    public func generateDocument() async {
        isGenerating = true
        generationProgress = 0.0
        defer { isGenerating = false }

        // TODO: Implement document generation
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        generationProgress = 1.0
    }
}

@MainActor
@Observable
public final class ProfileViewModel {
    public var profile: UserProfile
    public var isEditing: Bool = false
    public var isSaving: Bool = false
    public var showImagePicker: Bool = false
    public var selectedImageType: ImageType = .profile
    public var error: Error?

    public enum ImageType {
        case profile
        case organizationLogo
    }

    public init(profile: UserProfile = UserProfile()) {
        self.profile = profile
    }

    public func startEditing() {
        isEditing = true
    }

    public func cancelEditing() {
        isEditing = false
    }

    public func saveProfile() async {
        isSaving = true
        defer { isSaving = false }

        // TODO: Implement profile saving
        try? await Task.sleep(nanoseconds: 500_000_000)
        isEditing = false
    }

    public func showImagePicker(for type: ImageType) {
        selectedImageType = type
        showImagePicker = true
    }
}

@MainActor
@Observable
public final class OnboardingViewModel {
    public var currentStep: Int = 0
    public var totalSteps: Int = 5
    public var isCompleted: Bool = false
    public var userProfile: UserProfile = UserProfile()
    public var skipOnboarding: Bool = false

    public init() {}

    public func nextStep() {
        if currentStep < totalSteps - 1 {
            currentStep += 1
        } else {
            completeOnboarding()
        }
    }

    public func previousStep() {
        if currentStep > 0 {
            currentStep -= 1
        }
    }

    public func completeOnboarding() {
        isCompleted = true
    }

    public func skipToEnd() {
        skipOnboarding = true
        completeOnboarding()
    }
}

@MainActor
@Observable
public final class AcquisitionsListViewModel {
    public var acquisitions: [Acquisition] = []
    public var filteredAcquisitions: [Acquisition] = []
    public var searchText: String = ""
    public var selectedStatus: AcquisitionStatus?
    public var isLoading: Bool = false
    public var showingCreateAcquisition: Bool = false
    public var error: Error?

    public init() {
        filterAcquisitions()
    }

    public func loadAcquisitions() async {
        isLoading = true
        defer { isLoading = false }

        // TODO: Implement acquisition loading
        try? await Task.sleep(nanoseconds: 500_000_000)
        filterAcquisitions()
    }

    public func filterAcquisitions() {
        var filtered = acquisitions

        if !searchText.isEmpty {
            filtered = filtered.filter { acquisition in
                acquisition.title?.localizedCaseInsensitiveContains(searchText) == true ||
                acquisition.requirements?.localizedCaseInsensitiveContains(searchText) == true
            }
        }

        if let status = selectedStatus {
            filtered = filtered.filter { $0.status == status }
        }

        filteredAcquisitions = filtered
    }

    public func createAcquisition() {
        showingCreateAcquisition = true
    }

    public func deleteAcquisition(_ acquisition: Acquisition) {
        acquisitions.removeAll { $0.id == acquisition.id }
        filterAcquisitions()
    }
}

@MainActor
@Observable
public final class AcquisitionChatViewModel {
    public var acquisition: Acquisition?
    public var messages: [ChatMessage] = []
    public var currentMessage: String = ""
    public var isTyping: Bool = false
    public var isGeneratingResponse: Bool = false
    public var error: Error?

    public init() {}

    public func loadAcquisition(_ acquisition: Acquisition) {
        self.acquisition = acquisition
        loadChatHistory()
    }

    public func sendMessage() async {
        guard !currentMessage.isEmpty else { return }

        let userMessage = ChatMessage(content: currentMessage, isUser: true)
        messages.append(userMessage)

        let messageToSend = currentMessage
        currentMessage = ""

        isGeneratingResponse = true
        defer { isGeneratingResponse = false }

        // TODO: Implement AI response generation
        try? await Task.sleep(nanoseconds: 1_000_000_000)

        let aiResponse = ChatMessage(content: "AI response to: \(messageToSend)", isUser: false)
        messages.append(aiResponse)
    }

    private func loadChatHistory() {
        // TODO: Load chat history for acquisition
        messages = []
    }
}

@MainActor
@Observable
public final class SettingsViewModel {
    public var settings: SettingsData = SettingsData()
    public var isDarkMode: Bool = false
    public var enableNotifications: Bool = true
    public var autoSaveInterval: TimeInterval = 300 // 5 minutes
    public var showingAbout: Bool = false
    public var showingPrivacyPolicy: Bool = false
    public var isSaving: Bool = false
    public var error: Error?

    public init() {
        loadSettings()
    }

    public func loadSettings() {
        // TODO: Load settings from storage
    }

    public func saveSettings() async {
        isSaving = true
        defer { isSaving = false }

        // TODO: Save settings to storage
        try? await Task.sleep(nanoseconds: 500_000_000)
    }

    public func resetToDefaults() {
        settings = SettingsData()
        isDarkMode = false
        enableNotifications = true
        autoSaveInterval = 300
    }
}

@MainActor
@Observable
public final class DocumentScannerViewModel {
    public var isScanning: Bool = false
    public var scannedPages: [ScannedPage] = []
    public var currentPage: Int = 0
    public var scanQuality: ScanQuality = .high
    public var documentTitle: String = ""
    public var scanSession: ScanSession?
    public var error: Error?

    public enum ScanQuality {
        case low, medium, high
    }

    public init() {}

    public func startScanning() async {
        isScanning = true
        scanSession = ScanSession()

        // TODO: Implement document scanning
        try? await Task.sleep(nanoseconds: 1_000_000_000)

        isScanning = false
    }

    public func addPage(_ page: ScannedPage) {
        scannedPages.append(page)
        currentPage = scannedPages.count - 1
    }

    public func removePage(at index: Int) {
        guard index < scannedPages.count else { return }
        scannedPages.remove(at: index)
        if currentPage >= scannedPages.count {
            currentPage = max(0, scannedPages.count - 1)
        }
    }

    public func saveDocument() async {
        // TODO: Save scanned document
        try? await Task.sleep(nanoseconds: 500_000_000)
    }
}

@MainActor
@Observable
public final class GlobalScanViewModel {
    public var isGlobalScanEnabled: Bool = true
    public var scanTrigger: ScanTrigger = .floatingButton
    public var lastScanResult: ScanResult?
    public var scanHistory: [ScanResult] = []
    public var error: Error?

    public enum ScanTrigger {
        case floatingButton
        case keyboardShortcut
        case voiceCommand
    }

    public init() {}

    public func performGlobalScan() async {
        // TODO: Implement global scan functionality
        try? await Task.sleep(nanoseconds: 1_000_000_000)

        let result = ScanResult(content: "Scanned content", timestamp: Date())
        lastScanResult = result
        scanHistory.append(result)
    }

    public func clearHistory() {
        scanHistory.removeAll()
        lastScanResult = nil
    }
}

// MARK: - Supporting Types for ViewModels

public struct ChatMessage: Identifiable, Sendable {
    public let id = UUID()
    public let content: String
    public let isUser: Bool
    public let timestamp: Date

    public init(content: String, isUser: Bool, timestamp: Date = Date()) {
        self.content = content
        self.isUser = isUser
        self.timestamp = timestamp
    }
}

public struct ScanResult: Identifiable, Sendable {
    public let id = UUID()
    public let content: String
    public let timestamp: Date

    public init(content: String, timestamp: Date = Date()) {
        self.content = content
        self.timestamp = timestamp
    }
}
