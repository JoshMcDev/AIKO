import AppCore
import SwiftUI

#if canImport(UIKit)
    import UIKit
#elseif canImport(AppKit)
    import AppKit
#endif

@available(iOS 14.0, macOS 11.0, *)
public struct FloatingActionButton: View {
    @Environment(\.cameraService) private var cameraService
    @State private var isScanning = false
    @State private var buttonScale: CGFloat = 1.0
    @State private var shadowOpacity: Double = 0.3
    @State private var rotationAngle: Double = 0.0
    @State private var dragOffset: CGSize = .zero
    @State private var isDragging: Bool = false

    private let buttonSize: CGFloat = 56
    private let shadowRadius: CGFloat = 8
    private let animationDuration: Double = 0.2

    public init() {}

    public var body: some View {
        Button(action: {
            Task {
                isScanning = true
                defer { isScanning = false }

                do {
                    _ = try await cameraService.capturePhoto()
                } catch {
                    print("Camera capture failed: \(error)")
                }
            }
        }) {
            ZStack {
                if isScanning {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.2)
                } else {
                    Image(systemName: "doc.text.viewfinder")
                        .font(.system(size: 24, weight: .medium))
                        .foregroundColor(.white)
                }
            }
            .frame(width: buttonSize, height: buttonSize)
            .background(buttonBackground)
            .clipShape(Circle())
            .shadow(
                color: .black.opacity(shadowOpacity),
                radius: shadowRadius,
                x: 0,
                y: 4
            )
            .scaleEffect(buttonScale)
            .rotationEffect(.degrees(rotationAngle))
            .offset(dragOffset)
        }
        .disabled(isScanning)
        .buttonStyle(PlainButtonStyle())
        .accessibilityLabel("Global Scan Button")
        .accessibilityHint("Tap to start document scanning")
    }

    private var buttonBackground: some View {
        Circle()
            .fill(buttonGradient)
            .overlay(
                Circle()
                    .stroke(
                        LinearGradient(
                            colors: [.white.opacity(0.3), .clear],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            )
    }

    private var buttonGradient: LinearGradient {
        LinearGradient(
            colors: [
                Color(.systemBlue).opacity(0.9),
                Color(.systemBlue).opacity(0.7),
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}

@available(iOS 14.0, macOS 11.0, *)
public struct FloatingActionButtonContainer: View {
    @State private var position: FloatingPosition = .bottomTrailing

    public init() {}

    public var body: some View {
        GeometryReader { geometry in
            ZStack {
                FloatingActionButton()
                    .position(calculatePosition(for: position, in: geometry))
                    .animation(
                        .interpolatingSpring(stiffness: 300, damping: 30),
                        value: position
                    )
            }
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }

    private func calculatePosition(for position: FloatingPosition, in geometry: GeometryProxy) -> CGPoint {
        let buttonRadius: CGFloat = 28
        let margin: CGFloat = 20
        let safeArea = geometry.safeAreaInsets

        switch position {
        case .topLeading:
            return CGPoint(
                x: buttonRadius + margin + safeArea.leading,
                y: buttonRadius + margin + safeArea.top
            )
        case .topTrailing:
            return CGPoint(
                x: geometry.size.width - buttonRadius - margin - safeArea.trailing,
                y: buttonRadius + margin + safeArea.top
            )
        case .bottomLeading:
            return CGPoint(
                x: buttonRadius + margin + safeArea.leading,
                y: geometry.size.height - buttonRadius - margin - safeArea.bottom
            )
        case .bottomTrailing:
            return CGPoint(
                x: geometry.size.width - buttonRadius - margin - safeArea.trailing,
                y: geometry.size.height - buttonRadius - margin - safeArea.bottom
            )
        }
    }
}

public enum FloatingPosition: CaseIterable, Sendable {
    case topLeading
    case topTrailing
    case bottomLeading
    case bottomTrailing
}

@available(iOS 14.0, macOS 11.0, *)
public struct FloatingActionButtonOverlay: ViewModifier {
    public init() {}

    public func body(content: Content) -> some View {
        content
            .overlay(alignment: .topLeading) {
                FloatingActionButtonContainer()
            }
    }
}

@available(iOS 14.0, macOS 11.0, *)
public extension View {
    func floatingActionButton() -> some View {
        modifier(FloatingActionButtonOverlay())
    }
}
